name: Docker Integration Test

# Required GitHub Secrets:
# - ANTHROPIC_API_KEY: Claude API key for AI integration testing
# - NEXUS_GCS_CREDENTIALS: GCS service account JSON credentials (content of gcs-credentials.json)
#
# To add these secrets:
# 1. Go to: Settings > Secrets and variables > Actions
# 2. Click "New repository secret"
# 3. Add each secret with the exact name and value shown above

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
    paths:
      - 'Dockerfile'
      - 'docker-compose*.yml'
      - 'docker-start.sh'
      - 'docker-entrypoint.sh'
      - '.github/workflows/docker-integration.yml'

jobs:
  docker-build-and-init:
    name: Docker Build & Init Test
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Install Docker Compose
        run: |
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.24.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          docker-compose --version

      - name: Create required credentials files
        run: |
          # Create GCS credentials from GitHub secret
          echo '${{ secrets.NEXUS_GCS_CREDENTIALS }}' > gcs-credentials.json

          # Create .env.local file with config from GitHub secrets
          # Note: docker-start.sh looks for .env.local (not .env)
          cat > .env.local << 'EOF'
          # ============================================
          # PostgreSQL Database
          # ============================================
          POSTGRES_DB=nexus
          POSTGRES_USER=postgres
          POSTGRES_PASSWORD=nexus
          POSTGRES_PORT=5432

          # ============================================
          # Nexus Server
          # ============================================
          NEXUS_PORT=8080
          NEXUS_DATABASE_URL=postgresql://postgres:nexus@postgres:5432/nexus

          # Authentication - Dummy API Key for testing (proper Nexus format)
          NEXUS_API_KEY=sk-default_admin_dddddddd_eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee

          # Backend Storage
          NEXUS_BACKEND=local

          # GCS Backend (commented out - uncomment to test with GCS)
          # NEXUS_GCS_BUCKET=nexi-lab-nexus-hub-integration-test
          # NEXUS_GCS_PROJECT=nexi-lab-888
          # GOOGLE_APPLICATION_CREDENTIALS=/app/gcs-credentials.json

          # ============================================
          # API Keys (from GitHub secrets)
          # ============================================
          EOF

          # Append secrets to .env.local
          echo "ANTHROPIC_API_KEY=${{ secrets.ANTHROPIC_API_KEY }}" >> .env.local

          # ============================================
          # Configuration
          # ============================================
          echo "NEXUS_CONFIG_FILE=/app/configs/config.integration-test.yaml" >> .env.local

          # ============================================
          # OAuth & Permissions
          # ============================================
          echo "NEXUS_SKIP_PERMISSIONS=false" >> .env.local
          echo "VITE_SKIP_AUTH=false" >> .env.local

      - name: Verify credentials setup
        run: |
          echo "‚úÖ Verifying credentials files..."

          # Check GCS credentials file exists
          if [ -f gcs-credentials.json ]; then
            echo "‚úÖ gcs-credentials.json created ($(wc -c < gcs-credentials.json) bytes)"
          else
            echo "‚ùå gcs-credentials.json not found"
            exit 1
          fi

          # Check .env.local file exists and has required keys
          if [ -f .env.local ]; then
            echo "‚úÖ .env.local file created"
            echo "   - Checking required variables..."

            # Check ANTHROPIC_API_KEY has a value
            if grep -q "^ANTHROPIC_API_KEY=" .env.local && [ -n "$(grep "^ANTHROPIC_API_KEY=" .env.local | cut -d'=' -f2-)" ]; then
              KEY_VALUE=$(grep "^ANTHROPIC_API_KEY=" .env.local | cut -d'=' -f2-)
              echo "   ‚úÖ ANTHROPIC_API_KEY present (length: ${#KEY_VALUE} chars)"
            else
              echo "   ‚ùå ANTHROPIC_API_KEY missing or empty"
              echo "   ERROR: ANTHROPIC_API_KEY must be set in GitHub secrets"
              exit 1
            fi

            grep -q "POSTGRES_DB" .env.local && echo "   ‚úÖ POSTGRES_DB present" || echo "   ‚ùå POSTGRES_DB missing"
            grep -q "NEXUS_API_KEY" .env.local && echo "   ‚úÖ NEXUS_API_KEY present" || echo "   ‚ùå NEXUS_API_KEY missing"
          else
            echo "‚ùå .env.local file not found"
            exit 1
          fi

      - name: Make docker-start.sh executable
        run: chmod +x docker-start.sh

      - name: Test docker-start.sh --init --build
        run: |
          echo "üöÄ Testing docker-start.sh --init --build --yes..."
          ./docker-start.sh --init --build --yes
        timeout-minutes: 20

      - name: Wait for services to be healthy
        run: |
          echo "‚è≥ Waiting for services to become healthy..."

          MAX_WAIT=300  # 5 minutes (increased for LangGraph build time)
          ELAPSED=0

          while [ $ELAPSED -lt $MAX_WAIT ]; do
            # Check if all core services are healthy
            NEXUS_STATUS=$(docker inspect nexus-server --format='{{.State.Health.Status}}' 2>/dev/null || echo "not_found")
            POSTGRES_STATUS=$(docker inspect nexus-postgres --format='{{.State.Health.Status}}' 2>/dev/null || echo "not_found")
            LANGGRAPH_STATUS=$(docker inspect nexus-langgraph --format='{{.State.Health.Status}}' 2>/dev/null || echo "not_found")

            echo "[$ELAPSED s] nexus: $NEXUS_STATUS, postgres: $POSTGRES_STATUS, langgraph: $LANGGRAPH_STATUS"

            if [ "$NEXUS_STATUS" = "healthy" ] && [ "$POSTGRES_STATUS" = "healthy" ] && [ "$LANGGRAPH_STATUS" = "healthy" ]; then
              echo "‚úÖ All core services are healthy!"
              exit 0
            fi

            sleep 5
            ELAPSED=$((ELAPSED + 5))
          done

          echo "‚ùå Services did not become healthy within $MAX_WAIT seconds"
          docker ps -a
          echo "--- Nexus Server Logs ---"
          docker logs nexus-server
          echo "--- LangGraph Logs ---"
          docker logs nexus-langgraph
          exit 1

      - name: Verify service connectivity
        run: |
          echo "üîç Testing service connectivity..."

          # Test Nexus server health endpoint
          echo "Testing Nexus health endpoint..."
          HEALTH_RESPONSE=$(curl -sf http://localhost:8080/health || echo "FAILED")

          if [ "$HEALTH_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Health endpoint failed"
            docker logs nexus-server
            exit 1
          fi

          echo "‚úÖ Nexus health endpoint: $HEALTH_RESPONSE"

          # Test database connection by checking server logs
          echo "Checking database connection in logs..."
          if docker logs nexus-server 2>&1 | grep -q "PostgreSQL is ready"; then
            echo "‚úÖ PostgreSQL connection successful"
          else
            echo "‚ùå PostgreSQL connection failed"
            docker logs nexus-server
            exit 1
          fi

          # Test LangGraph health endpoint
          echo "Testing LangGraph health endpoint..."
          LANGGRAPH_RESPONSE=$(curl -sf http://localhost:2024/ok || echo "FAILED")

          if [ "$LANGGRAPH_RESPONSE" = "FAILED" ]; then
            echo "‚ùå LangGraph health endpoint failed"
            docker logs nexus-langgraph
            exit 1
          fi

          echo "‚úÖ LangGraph health endpoint: $LANGGRAPH_RESPONSE"

      - name: Test API key configuration
        run: |
          echo "üîë Verifying API key configuration..."

          # Since we provided a dummy key, verify the server is using it
          # Check if server started successfully (indicates key was accepted)
          if docker logs nexus-server 2>&1 | grep -q "Server initialization complete"; then
            echo "‚úÖ Nexus server started with configured API key"
          else
            echo "‚ùå Server startup issue - check API key configuration"
            docker logs nexus-server
            exit 1
          fi

          # Verify ANTHROPIC_API_KEY is set in LangGraph container
          echo ""
          echo "üîç Checking ANTHROPIC_API_KEY in LangGraph container..."
          LANG_KEY=$(docker exec nexus-langgraph printenv ANTHROPIC_API_KEY || echo "")
          if [ -n "$LANG_KEY" ]; then
            echo "‚úÖ ANTHROPIC_API_KEY is set in LangGraph container (length: ${#LANG_KEY} chars)"
          else
            echo "‚ùå ANTHROPIC_API_KEY is NOT set in LangGraph container"
            echo "   Checking .env.local file..."
            grep "ANTHROPIC_API_KEY" .env.local || echo "   Not found in .env.local"
            echo "   Checking docker-compose environment..."
            docker-compose -f docker-compose.demo.yml config | grep -A 5 "ANTHROPIC_API_KEY" || echo "   Not found in docker-compose config"
            exit 1
          fi

      - name: Test basic RPC API call
        run: |
          echo "üì° Testing basic RPC API functionality..."

          # Use known dummy API key (set in .env)
          API_KEY="sk-default_admin_dddddddd_eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
          echo "Using API key: ${API_KEY:0:20}..."

          # Test list_mounts endpoint
          RESPONSE=$(curl -sf http://localhost:8080/api/nfs/list_mounts \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d '{"jsonrpc":"2.0","id":1,"method":"list_mounts","params":{}}' || echo "FAILED")

          if [ "$RESPONSE" = "FAILED" ]; then
            echo "‚ùå RPC API call failed"
            docker logs nexus-server
            exit 1
          fi

          echo "‚úÖ RPC API call successful"
          echo "Response: $RESPONSE"

      - name: End-to-End Integration Test
        run: |
          echo "üß™ Running comprehensive end-to-end integration test..."

          # Use known dummy API key (set in .env)
          API_KEY="sk-default_admin_dddddddd_eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
          echo "Using API key: ${API_KEY:0:20}..."

          # Generate unique test directory with timestamp
          TEST_DIR="/test_$(date +%s)"
          echo "Test directory: $TEST_DIR"
          echo ""

          # Step 1: Create directory with timestamp
          echo "üìÅ Step 1: Creating directory $TEST_DIR..."
          MKDIR_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/mkdir \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"mkdir\",\"params\":{\"path\":\"$TEST_DIR\"}}" || echo "FAILED")

          if [ "$MKDIR_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to create directory"
            exit 1
          fi
          echo "‚úÖ Directory created: $MKDIR_RESPONSE"

          # Step 2: Write numbers.txt with "1, 5, 16"
          echo "üìù Step 2: Writing $TEST_DIR/numbers.txt..."
          WRITE_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/write \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"write\",\"params\":{\"path\":\"$TEST_DIR/numbers.txt\",\"content\":\"1, 5, 16\"}}" || echo "FAILED")

          if [ "$WRITE_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to write file"
            exit 1
          fi
          echo "‚úÖ File written: $WRITE_RESPONSE"

          # Step 3: List files to verify
          echo "üìã Step 3: Listing files in $TEST_DIR..."
          LIST_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/list \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"id\":3,\"method\":\"list\",\"params\":{\"path\":\"$TEST_DIR\"}}" || echo "FAILED")

          if [ "$LIST_RESPONSE" = "FAILED" ] || ! echo "$LIST_RESPONSE" | grep -q "numbers.txt"; then
            echo "‚ùå Failed to list files or numbers.txt not found"
            echo "Response: $LIST_RESPONSE"
            exit 1
          fi
          echo "‚úÖ Files listed: $LIST_RESPONSE"

          # Step 4: Register langgraph agent
          echo "ü§ñ Step 4: Registering LangGraph agent..."
          REGISTER_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/register_agent \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d '{"jsonrpc":"2.0","id":4,"method":"register_agent","params":{"agent_id":"admin,nexus_assistant_1","name":"nexus_assistant_1","description":"A claude-code like general agent that connects to Nexus File System.","generate_api_key":false}}' || echo "FAILED")

          if [ "$REGISTER_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to register agent"
            exit 1
          fi
          echo "‚úÖ Agent registered: $REGISTER_RESPONSE"

          # Step 5: Create sandbox
          echo "üê≥ Step 5: Creating sandbox..."
          SANDBOX_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/sandbox_get_or_create \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d '{"jsonrpc":"2.0","id":5,"method":"sandbox_get_or_create","params":{"name":"admin,nexus_assistant_1","ttl_minutes":60,"provider":"docker","verify_status":true}}' || echo "FAILED")

          if [ "$SANDBOX_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to create sandbox"
            exit 1
          fi

          # Extract sandbox_id from response using Python JSON parser
          SANDBOX_ID=$(echo "$SANDBOX_RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('sandbox_id', ''))" 2>/dev/null || echo "")
          if [ -z "$SANDBOX_ID" ]; then
            echo "‚ùå Could not extract sandbox_id"
            echo "Response: $SANDBOX_RESPONSE"
            exit 1
          fi
          echo "‚úÖ Sandbox created: $SANDBOX_ID"

          # Wait for LangGraph to be ready
          echo "‚è≥ Waiting for LangGraph service..."
          sleep 10

          # Step 6: Create LangGraph thread
          echo "üßµ Step 6: Creating LangGraph thread..."
          THREAD_RESPONSE=$(curl -sf http://localhost:2024/threads \
            -H "Content-Type: application/json" \
            -d "{\"nexus_server_url\":\"http://nexus:8080\",\"sandbox_id\":\"$SANDBOX_ID\",\"selectedAgentId\":\"admin,nexus_assistant_1\",\"user_id\":\"admin\",\"x_auth\":\"Bearer $API_KEY\"}" || echo "FAILED")

          if [ "$THREAD_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to create thread"
            exit 1
          fi

          # Extract thread_id
          THREAD_ID=$(echo "$THREAD_RESPONSE" | grep -o '"thread_id":"[^"]*"' | cut -d'"' -f4)
          if [ -z "$THREAD_ID" ]; then
            echo "‚ùå Could not extract thread_id"
            echo "Response: $THREAD_RESPONSE"
            exit 1
          fi
          echo "‚úÖ Thread created: $THREAD_ID"

          # Step 7: Execute sum calculation task
          echo "üî¢ Step 7: Executing sum calculation task..."
          TASK_RESPONSE=$(curl -sf http://localhost:2024/threads/$THREAD_ID/runs/stream \
            -H "Content-Type: application/json" \
            -d "{\"input\":{\"messages\":[{\"type\":\"human\",\"content\":\"Read the file $TEST_DIR/numbers.txt, calculate the sum of all the numbers in it, and write the sum to $TEST_DIR/sum.txt\"}]},\"metadata\":{\"user_id\":\"admin\",\"selectedAgentId\":\"admin,nexus_assistant_1\",\"x_auth\":\"Bearer $API_KEY\",\"nexus_server_url\":\"http://nexus:8080\",\"sandbox_id\":\"$SANDBOX_ID\"},\"stream_mode\":[\"messages-tuple\",\"values\"],\"stream_resumable\":false,\"assistant_id\":\"agent\",\"on_disconnect\":\"cancel\"}" \
            --no-buffer || echo "FAILED")

          if [ "$TASK_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to execute task"
            exit 1
          fi
          echo "‚úÖ Task executed"

          # Wait for task completion
          echo "‚è≥ Waiting for task completion..."
          sleep 15

          # Step 8: Verify sum.txt contains 22
          echo "‚úÖ Step 8: Verifying sum.txt..."
          READ_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/read \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"id\":8,\"method\":\"read\",\"params\":{\"path\":\"$TEST_DIR/sum.txt\"}}" || echo "FAILED")

          if [ "$READ_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to read sum.txt"
            exit 1
          fi

          # Extract and decode base64 content
          CONTENT=$(echo "$READ_RESPONSE" | python3 -c "import sys, json, base64; data=json.load(sys.stdin); print(base64.b64decode(data['result']['data']).decode('utf-8').strip())" 2>/dev/null || echo "")

          echo "Content of sum.txt: $CONTENT"

          if [ "$CONTENT" = "22" ]; then
            echo "‚úÖ sum.txt contains correct result (22)"
          else
            echo "‚ùå sum.txt does not contain expected result (22)"
            echo "Response: $READ_RESPONSE"
            exit 1
          fi

          echo "üéâ End-to-end integration test completed successfully!"

      - name: User Permission Grant Test
        run: |
          echo "üîê Testing user permission grant workflow..."
          echo ""

          # Use known dummy API key (set in .env) for admin
          ADMIN_API_KEY="sk-default_admin_dddddddd_eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
          echo "Using admin API key: ${ADMIN_API_KEY:0:20}..."
          echo ""

          # Generate unique test user and file with timestamp
          TIMESTAMP=$(date +%s)
          TEST_USER="testuser_${TIMESTAMP}"
          ADMIN_FILE="/admin_secret_${TIMESTAMP}.txt"
          ADMIN_FILE_CONTENT="This is admin-only content"
          echo "Test user: $TEST_USER"
          echo "Admin file: $ADMIN_FILE"
          echo ""

          # Step 1: Create a new non-admin user
          echo "üë§ Step 1: Creating non-admin user $TEST_USER..."
          CREATE_USER_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/admin_create_key \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ADMIN_API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"id\":1,\"method\":\"admin_create_key\",\"params\":{\"user_id\":\"$TEST_USER\",\"name\":\"Test User Key\",\"is_admin\":false,\"tenant_id\":\"default\"}}" || echo "FAILED")

          if [ "$CREATE_USER_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to create user"
            exit 1
          fi

          # Extract API key from response
          USER_API_KEY=$(echo "$CREATE_USER_RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('result', {}).get('api_key', ''))" 2>/dev/null || echo "")
          if [ -z "$USER_API_KEY" ]; then
            echo "‚ùå Could not extract user API key"
            echo "Response: $CREATE_USER_RESPONSE"
            exit 1
          fi
          echo "‚úÖ User created: $TEST_USER"
          echo "   API key: ${USER_API_KEY:0:30}..."
          echo ""

          # Step 2: Admin creates a file
          echo "üìù Step 2: Admin creating file $ADMIN_FILE..."
          # Encode content as base64 for bytes format
          ADMIN_FILE_CONTENT_B64=$(echo -n "$ADMIN_FILE_CONTENT" | base64)
          WRITE_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/write \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ADMIN_API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"id\":2,\"method\":\"write\",\"params\":{\"path\":\"$ADMIN_FILE\",\"content\":{\"__type__\":\"bytes\",\"data\":\"$ADMIN_FILE_CONTENT_B64\"}}}" || echo "FAILED")

          if [ "$WRITE_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to create admin file"
            exit 1
          fi
          echo "‚úÖ Admin file created: $ADMIN_FILE"
          echo ""

          # Step 3: Grant admin ownership of the file (required for permission management)
          echo "üîë Step 3: Granting admin ownership of $ADMIN_FILE..."
          OWNER_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/rebac_create \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ADMIN_API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"id\":3,\"method\":\"rebac_create\",\"params\":{\"subject\":[\"user\",\"admin\"],\"relation\":\"direct_owner\",\"object\":[\"file\",\"$ADMIN_FILE\"],\"tenant_id\":\"default\"}}" || echo "FAILED")

          if [ "$OWNER_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to grant admin ownership"
            exit 1
          fi
          echo "‚úÖ Admin ownership granted"
          echo ""

          # Step 4: Try to read the file as non-admin user (should fail)
          echo "üö´ Step 4: Attempting to read $ADMIN_FILE as $TEST_USER (should fail)..."
          READ_RESPONSE=$(curl -s http://localhost:8080/api/nfs/read \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $USER_API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"id\":4,\"method\":\"read\",\"params\":{\"path\":\"$ADMIN_FILE\"}}" 2>&1)

          # Check if response contains error (JSON-RPC error format)
          ERROR_CODE=$(echo "$READ_RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('error', {}).get('code', ''))" 2>/dev/null || echo "")
          ERROR_MESSAGE=$(echo "$READ_RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('error', {}).get('message', ''))" 2>/dev/null || echo "")

          # Check for permission error (code -32004) or permission-related message
          if [ "$ERROR_CODE" = "-32004" ] || echo "$ERROR_MESSAGE" | grep -qi "permission\|access denied"; then
            echo "‚úÖ Access correctly denied (user cannot read admin file)"
            echo "   Error code: $ERROR_CODE"
            echo "   Error message: $ERROR_MESSAGE"
          else
            echo "‚ùå Access should have been denied, but request succeeded or returned unexpected error"
            echo "Response: $READ_RESPONSE"
            exit 1
          fi
          echo ""

          # Step 5: Admin grants read permission to the user
          echo "üîì Step 5: Admin granting read permission to $TEST_USER..."
          GRANT_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/rebac_create \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $ADMIN_API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"id\":5,\"method\":\"rebac_create\",\"params\":{\"subject\":[\"user\",\"$TEST_USER\"],\"relation\":\"direct_viewer\",\"object\":[\"file\",\"$ADMIN_FILE\"],\"tenant_id\":\"default\"}}" || echo "FAILED")

          if [ "$GRANT_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to grant permission"
            exit 1
          fi
          echo "‚úÖ Permission granted: $TEST_USER can now read $ADMIN_FILE"
          echo ""

          # Step 6: Try to read the file as non-admin user again (should succeed)
          echo "‚úÖ Step 6: Attempting to read $ADMIN_FILE as $TEST_USER (should succeed)..."
          READ_RESPONSE=$(curl -s http://localhost:8080/api/nfs/read \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $USER_API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"id\":6,\"method\":\"read\",\"params\":{\"path\":\"$ADMIN_FILE\"}}")

          # Check for errors first
          ERROR_CODE=$(echo "$READ_RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('error', {}).get('code', ''))" 2>/dev/null || echo "")
          if [ -n "$ERROR_CODE" ]; then
            ERROR_MESSAGE=$(echo "$READ_RESPONSE" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('error', {}).get('message', ''))" 2>/dev/null || echo "")
            echo "‚ùå Failed to read file after permission grant"
            echo "   Error code: $ERROR_CODE"
            echo "   Error message: $ERROR_MESSAGE"
            echo "   Response: $READ_RESPONSE"
            exit 1
          fi

          # Extract and decode base64 content (bytes are serialized as {"__type__": "bytes", "data": "<base64>"})
          CONTENT=$(echo "$READ_RESPONSE" | python3 -c "import sys, json, base64; data = json.load(sys.stdin); result = data.get('result', {}); content = base64.b64decode(result['data']).decode('utf-8').strip() if isinstance(result, dict) and result.get('__type__') == 'bytes' else (base64.b64decode(result['data']).decode('utf-8').strip() if isinstance(result, dict) and 'data' in result else ''); print(content)" 2>/dev/null || echo "")

          if [ "$CONTENT" = "$ADMIN_FILE_CONTENT" ]; then
            echo "‚úÖ User successfully read admin file after permission grant"
            echo "   Content: $CONTENT"
          else
            echo "‚ùå File content doesn't match expected value"
            echo "Expected: $ADMIN_FILE_CONTENT"
            echo "Got: $CONTENT"
            echo "Response: $READ_RESPONSE"
            exit 1
          fi
          echo ""

          echo "üéâ User permission grant test completed successfully!"

      - name: Authenticate gcloud with service account
        run: |
          echo "üîê Authenticating gcloud with service account..."

          # Authenticate using the service account credentials
          gcloud auth activate-service-account --key-file=gcs-credentials.json

          # Set the project
          gcloud config set project nexi-lab-888

          # Verify authentication
          echo "‚úÖ gcloud authenticated:"
          gcloud auth list

      - name: Mount Integration Test
        run: |
          echo "üóÑÔ∏è Running mount integration test..."

          # Use known dummy API key (set in .env)
          API_KEY="sk-default_admin_dddddddd_eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee"
          echo "Using API key: ${API_KEY:0:20}..."
          echo ""

          # Generate timestamp for unique file and mount point
          TIMESTAMP=$(date +%s)
          MOUNT_POINT="/mnt_test_${TIMESTAMP}"
          echo "Timestamp: $TIMESTAMP"
          echo "Mount point: $MOUNT_POINT"
          echo ""

          # Step 1: Save mount
          echo "üíæ Step 1: Saving mount $MOUNT_POINT..."
          SAVE_MOUNT_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/save_mount \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"save_mount\",\"params\":{\"mount_point\":\"$MOUNT_POINT\",\"backend_type\":\"gcs_connector\",\"backend_config\":{\"bucket\":\"nexi-lab-nexus-hub-integration-test\",\"project_id\":\"nexi-lab-888\",\"prefix\":\"\",\"access_token\":\"\"},\"priority\":10,\"readonly\":false,\"description\":\"Integration test mount\"},\"id\":1}" || echo "FAILED")

          if [ "$SAVE_MOUNT_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to save mount"
            exit 1
          fi
          echo "‚úÖ Mount saved: $SAVE_MOUNT_RESPONSE"
          echo ""

          # Step 2: Load mount
          echo "üìÇ Step 2: Loading mount $MOUNT_POINT..."
          LOAD_MOUNT_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/load_mount \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"load_mount\",\"params\":{\"mount_point\":\"$MOUNT_POINT\"},\"id\":2}" || echo "FAILED")

          if [ "$LOAD_MOUNT_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to load mount"
            exit 1
          fi
          echo "‚úÖ Mount loaded: $LOAD_MOUNT_RESPONSE"
          echo ""

          # Step 3: Sync mount
          echo "üîÑ Step 3: Syncing mount $MOUNT_POINT..."
          SYNC_MOUNT_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/sync_mount \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"sync_mount\",\"params\":{\"mount_point\":\"$MOUNT_POINT\",\"recursive\":true},\"id\":3}" || echo "FAILED")

          if [ "$SYNC_MOUNT_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to sync mount"
            exit 1
          fi
          echo "‚úÖ Mount synced: $SYNC_MOUNT_RESPONSE"
          echo ""

          # Step 4: Read CSV file and verify headers
          echo "üìÑ Step 4: Reading $MOUNT_POINT/sample_customers.csv..."
          READ_CSV_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/read \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"read\",\"params\":{\"path\":\"$MOUNT_POINT/sample_customers.csv\"},\"id\":4}" || echo "FAILED")

          if [ "$READ_CSV_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to read CSV file"
            exit 1
          fi

          # Extract and decode base64 content
          CSV_CONTENT=$(echo "$READ_CSV_RESPONSE" | python3 -c "import sys, json, base64; data=json.load(sys.stdin); print(base64.b64decode(data['result']['data']).decode('utf-8'))" 2>/dev/null || echo "")

          echo "CSV content (first 200 chars): ${CSV_CONTENT:0:200}"
          echo ""

          # Verify CSV headers
          if echo "$CSV_CONTENT" | head -1 | grep -q "customer_name,contact_name,contact_phone,contact_email"; then
            echo "‚úÖ CSV headers verified: customer_name,contact_name,contact_phone,contact_email"
          else
            echo "‚ùå CSV headers don't match expected format"
            echo "First line: $(echo "$CSV_CONTENT" | head -1)"
            exit 1
          fi
          echo ""

          # Step 5: Write timestamped file
          echo "‚úçÔ∏è  Step 5: Writing $MOUNT_POINT/test_${TIMESTAMP}.txt..."

          # Encode timestamp as base64
          TIMESTAMP_BASE64=$(echo -n "$TIMESTAMP" | base64)

          WRITE_FILE_RESPONSE=$(curl -sf http://localhost:8080/api/nfs/write \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $API_KEY" \
            -d "{\"jsonrpc\":\"2.0\",\"method\":\"write\",\"params\":{\"path\":\"$MOUNT_POINT/test_${TIMESTAMP}.txt\",\"content\":{\"__type__\":\"bytes\",\"data\":\"$TIMESTAMP_BASE64\"}},\"id\":5}" || echo "FAILED")

          if [ "$WRITE_FILE_RESPONSE" = "FAILED" ]; then
            echo "‚ùå Failed to write file"
            exit 1
          fi
          echo "‚úÖ File written: $WRITE_FILE_RESPONSE"
          echo ""

          # Step 6: Verify file in GCS bucket
          echo "‚òÅÔ∏è  Step 6: Verifying file in GCS bucket..."

          # Wait a moment for the write to propagate
          sleep 3

          # Use gcloud to read the file directly from GCS
          GCS_FILE_CONTENT=$(gcloud storage cat gs://nexi-lab-nexus-hub-integration-test/test_${TIMESTAMP}.txt 2>/dev/null || echo "FAILED")

          if [ "$GCS_FILE_CONTENT" = "FAILED" ]; then
            echo "‚ùå Failed to read file from GCS bucket"
            exit 1
          fi

          echo "GCS file content: $GCS_FILE_CONTENT"

          # Verify content matches timestamp
          if [ "$GCS_FILE_CONTENT" = "$TIMESTAMP" ]; then
            echo "‚úÖ GCS file content verified: matches timestamp $TIMESTAMP"
          else
            echo "‚ùå GCS file content doesn't match expected timestamp"
            echo "Expected: $TIMESTAMP"
            echo "Got: $GCS_FILE_CONTENT"
            exit 1
          fi
          echo ""

          echo "üéâ Mount integration test completed successfully!"

      - name: Display service logs on failure
        if: failure()
        run: |
          echo "=== Docker Compose PS ==="
          docker-compose ps -a

          echo "=== Nexus Server Logs ==="
          docker logs nexus-server 2>&1 || true

          echo "=== PostgreSQL Logs ==="
          docker logs nexus-postgres 2>&1 || true

          echo "=== LangGraph Logs ==="
          docker logs nexus-langgraph 2>&1 || true

          echo "=== Frontend Logs ==="
          docker logs nexus-frontend 2>&1 || true

          echo "=== MCP Server Logs ==="
          docker logs nexus-mcp-server 2>&1 || true

      - name: Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up containers..."
          ./docker-start.sh --stop || true
          docker system prune -af || true
