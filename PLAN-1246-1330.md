# Implementation Plan: #1246 + #1330 — Consolidate Dual-Write + Replace sled with redb

## Decisions Summary

| # | Decision | Choice |
|---|----------|--------|
| 1 | Ordering | Combined phased PR — redb for Raft internals + consolidation |
| 2 | SSOT | Hybrid — PostgreSQL for file metadata, redb for Raft log + CTO revisions |
| 3 | Missing observers | Centralize through `_commit_metadata()` + add missing calls |
| 4 | Atomicity | Eventual consistency + background reconciler |
| 5 | Mapping DRY | Do nothing (consolidation eliminates dual representation) |
| 6 | Error policy | Central `_notify_observer()` helper for all 4 call sites |
| 7 | God method | Extract post-write hooks into named methods |
| 8 | Validation DRY | Do nothing (consolidation eliminates it) |
| 9 | Syncer tests | Create `test_record_store_syncer.py` with failure injection |
| 10 | Strict mode tests | TDD — write tests BEFORE `_notify_observer()` refactor |
| 11 | Consistency tests | Dual-consistency integration tests |
| 12 | Observer call tests | Mock observer assertion tests for ALL write paths |
| 13 | SQL query overhead | Accept current (consolidation eliminates observer) |
| 14 | Revision counter | Dedicated redb `TableDefinition<&str, u64>` for revisions |
| 15 | Read latency | redb as read cache, SQL as SSOT (write-through) |
| 16 | Batch flush | Add `flush=True` param to `log_operation()` |

---

## Phase 1: Test Foundation (Safety Net)

**Goal:** Build test coverage BEFORE any refactoring. TDD: red first.

### 1.1 Create `tests/unit/storage/test_record_store_syncer.py` (#9)
- Test happy path: `on_write()`, `on_delete()`, `on_rename()`, `on_write_batch()`
- Test SQL failure: mock session to raise `OperationalError` during commit
- Test partial failure: `OperationLogger` succeeds, `VersionRecorder` raises
- Test session exhaustion: session factory raises
- **Files:** `tests/unit/storage/test_record_store_syncer.py` (new)

### 1.2 Test `audit_strict_mode` behavior (#10)
- Test `write()` with `audit_strict_mode=True` + observer failure -> raises `AuditLogError`
- Test `write()` with `audit_strict_mode=False` + observer failure -> logs CRITICAL, returns success
- Test `delete()` / `rename()` / `write_batch()` currently suppress errors (document current behavior)
- **Files:** `tests/unit/core/test_audit_strict_mode.py` (new)

### 1.3 Mock observer assertion tests for ALL write paths (#12)
- Mock `_write_observer`, call `fs.write()` -> assert `on_write()` called with correct args
- Mock `_write_observer`, call `fs.delete()` -> assert `on_delete()` called
- Mock `_write_observer`, call `fs.rename()` -> assert `on_rename()` called
- Mock `_write_observer`, call `fs.write_batch()` -> assert `on_write_batch()` called
- Assert `write_stream()`, `mkdir()`, `rmdir()` do NOT call observer (document current gap)
- **Files:** `tests/unit/core/test_write_observer_calls.py` (new)

### 1.4 Dual-consistency integration tests (#11)
- After `fs.write()`: verify file exists in BOTH Metastore AND RecordStore with matching fields
- After `fs.delete()`: verify file removed from Metastore, soft-deleted in RecordStore
- After `fs.rename()`: verify path updated in Metastore, audit entry in RecordStore
- After `fs.write_batch()`: verify all files in both stores
- **Files:** `tests/integration/test_dual_write_consistency.py` (new)

---

## Phase 2: Python Refactoring (Code Quality)

**Goal:** Clean up the write path before the storage layer migration.

### 2.1 Extract `_notify_observer()` helper (#6)
- Create `_notify_observer(method_name, **kwargs)` on `NexusFSCoreMixin`
- Handles: try/except, `audit_strict_mode` check, logging
- Replace all 4 call sites: `write()`, `delete()`, `rename()`, `write_batch()`
- All paths now respect `audit_strict_mode` uniformly
- **Files:** `src/nexus/core/nexus_fs_core.py`

### 2.2 Extract post-write hooks into named methods (#7)
- `_apply_leopard_grants(path, zone_id, context, meta)` — lines 1871-1891
- `_invalidate_parsed_cache(path, meta)` — lines 1895-1901
- `_sync_permissions(path, zone_id, context, meta)` — lines 1916-1960
- `_sync_audit(metadata, meta, path, zone_id, agent_id, ...)` — lines 1966-1996
- `_fire_workflow_events(path, content, zone_id, agent_id, ...)` — lines 1998-2040+
- `_write_internal()` becomes ~30 lines calling these hooks sequentially
- **Files:** `src/nexus/core/nexus_fs_core.py`

### 2.3 Centralize writes through `_commit_metadata()` (#3)
- Create `_commit_metadata(metadata, *, is_new, path, zone_id, agent_id, ...)` helper
- Calls `self.metadata.put(metadata)` + `self._notify_observer(...)` in one place
- Add observer calls to `write_stream()`, `mkdir()`, `rmdir()`
- Update tests from Phase 1.3 to verify NEW observer calls on `write_stream/mkdir/rmdir`
- **Files:** `src/nexus/core/nexus_fs_core.py`, `src/nexus/core/nexus_fs.py`

### 2.4 Add `flush` parameter to `log_operation()` (#16)
- Add `flush: bool = True` to `OperationLogger.log_operation()`
- `on_write_batch()` passes `flush=False`, single flush at end of batch
- **Files:** `src/nexus/storage/operation_logger.py`, `src/nexus/storage/record_store_syncer.py`

---

## Phase 3: Rust — Replace sled with redb (#1330)

**Goal:** Swap the embedded KV store while preserving the exact same Python-facing API.

### 3.1 Create `RedbStore` matching `SledStore` API
- New file: `rust/nexus_raft/src/storage/redb_store.rs`
- Map SledStore's 12 methods to redb equivalents:
  - `open(path)` -> `Database::create(path)`
  - `open_temporary()` -> `Database::create(tempfile)`
  - `get/set/delete` -> read/write transactions
  - `flush()` -> automatic on commit (use `Durability::Immediate`)
  - `generate_id()` -> atomic counter in dedicated table
- Map SledTree's 18 methods:
  - `scan_prefix()` -> `table.range(prefix..compute_end(prefix))`
  - `compare_and_swap()` -> read-then-write within write transaction
  - `batch()` -> write transaction with multiple operations
- **Files:** `rust/nexus_raft/src/storage/redb_store.rs` (new)

### 3.2 Add dedicated revision counter table (#14)
- Define: `const REVISIONS: TableDefinition<&str, u64> = TableDefinition::new("revisions");`
- Add `increment_revision(zone_id) -> u64` method to RedbStore/StateMachine
- Expose via PyO3 binding: `PyMetastore.increment_revision(zone_id)`
- No Python lock needed — redb's single-writer transaction provides atomicity
- **Files:** `rust/nexus_raft/src/storage/redb_store.rs`, `rust/nexus_raft/src/raft/state_machine.rs`, `rust/nexus_raft/src/pyo3_bindings.rs`

### 3.3 Define 5+1 static tables matching current sled trees
```rust
const RAFT_ENTRIES: TableDefinition<u64, &[u8]> = TableDefinition::new("raft_entries");
const RAFT_STATE: TableDefinition<&[u8], &[u8]> = TableDefinition::new("raft_state");
const SM_METADATA: TableDefinition<&str, &[u8]> = TableDefinition::new("sm_metadata");
const SM_LOCKS: TableDefinition<&str, &[u8]> = TableDefinition::new("sm_locks");
const WITNESS_LOG: TableDefinition<&str, &[u8]> = TableDefinition::new("witness_log");
const REVISIONS: TableDefinition<&str, u64> = TableDefinition::new("revisions");
```
- **Files:** `rust/nexus_raft/src/storage/redb_store.rs`

### 3.4 Port `FullStateMachine` to use RedbStore
- Replace `SledTree` references with `RedbStore` table access
- Update `apply()`, `snapshot()`, `restore_snapshot()` methods
- `list_metadata()` / `list_locks()`: replace `scan_prefix()` with `range()` + prefix upper-bound computation
- **Files:** `rust/nexus_raft/src/raft/state_machine.rs`

### 3.5 Port `RaftStorage` to use RedbStore
- Replace sled tree access in `append()`, `compact()`, `apply_snapshot()`
- Replace `sled::Batch` with redb write transactions
- **Files:** `rust/nexus_raft/src/raft/storage.rs`

### 3.6 Port `WitnessStateMachine` to use RedbStore
- Replace `SledTree` with `WITNESS_LOG` table access
- **Files:** `rust/nexus_raft/src/raft/state_machine.rs`

### 3.7 Update Cargo.toml
- Remove: `sled = "0.34"`
- Add: `redb = "2"` (latest stable)
- Add: `tempfile = "3"` (for temporary databases in tests)
- **Files:** `rust/nexus_raft/Cargo.toml`

### 3.8 Update PyO3 bindings
- Replace `SledStore` with `RedbStore` in `PyMetastore` and `PyRaftConsensus`
- Add `increment_revision()` binding
- **Files:** `rust/nexus_raft/src/pyo3_bindings.rs`

### 3.9 Write Rust unit tests
- Test all RedbStore methods (parity with SledStore behavior)
- Test revision counter atomicity
- Test scan_prefix -> range equivalence
- Test snapshot/restore round-trip
- **Files:** `rust/nexus_raft/src/storage/redb_store.rs` (inline tests) or `rust/nexus_raft/tests/`

### 3.10 One-time data migration tool (sled -> redb)
- CLI tool that reads all sled trees and writes to redb tables
- Only needed for existing deployments with data in sled
- **Files:** `rust/nexus_raft/src/bin/migrate_sled_to_redb.rs` (new)

---

## Phase 4: Consolidation — PostgreSQL as SSOT for file metadata (#1246)

**Goal:** Make SQL the source of truth for file metadata. redb becomes read cache + Raft internals.

### 4.1 Create `SqlMetadataStore` implementing `FileMetadataProtocol`
- Implements `get()`, `put()`, `delete()`, `exists()`, `list()`, `batch_*()` using SQLAlchemy
- Write path: SQL first (SSOT), then update redb cache (write-through)
- Read path: redb first (fast ~5us), fall back to SQL on cache miss
- **Files:** `src/nexus/storage/sql_metadata_store.py` (new)

### 4.2 Update `_increment_and_get_revision()` to use native redb counter
- Replace `FileMetadata` abuse with direct `self.metadata.increment_revision(zone_id)` call
- Remove Python `_revision_lock` (redb's single-writer provides atomicity)
- **Files:** `src/nexus/core/nexus_fs_core.py`

### 4.3 Update `factory.py` to wire `SqlMetadataStore`
- Replace `RaftMetadataStore` with `SqlMetadataStore` for file metadata
- Keep redb for Raft log, CTO revision counters, distributed locks
- RecordStoreSyncer becomes unnecessary (writes go directly to SQL)
- **Files:** `src/nexus/factory.py`

### 4.4 Build background reconciler (#4)
- Periodically compare redb cache state with SQL SSOT
- Detect and resolve inconsistencies (stale cache entries, orphaned records)
- Log reconciliation results for monitoring
- Configurable interval (default: every 60 seconds)
- **Files:** `src/nexus/storage/reconciler.py` (new)

### 4.5 Deprecate and remove RecordStoreSyncer
- Remove `RecordStoreSyncer`, `_write_observer`, `_audit_strict_mode`
- Remove `_notify_observer()` helper (no longer needed — SQL is direct)
- OperationLogger and VersionRecorder write directly in the SqlMetadataStore
- **Files:** Remove `src/nexus/storage/record_store_syncer.py`, update `nexus_fs_core.py`

---

## Phase 5: Validation & Cleanup

### 5.1 Run all existing tests
- Unit tests: `PYTHONPATH=src python3.14 -m pytest tests/unit/ -v`
- Integration tests: `PYTHONPATH=src python3.14 -m pytest tests/integration/ -v`
- E2E tests (with LocalRaft): `.venv/bin/python3.12 -m pytest tests/e2e/ -v`

### 5.2 Update Phase 1 tests for new architecture
- Dual-consistency tests: update to verify SQL SSOT + redb cache
- Observer tests: update to reflect observer removal (or convert to SqlMetadataStore tests)

### 5.3 Rust tests
- `cargo test` in `rust/nexus_raft/`
- Verify redb migration tool works on test sled databases

### 5.4 Performance benchmark
- Compare write latency: before (sled SSOT + SQL observer) vs after (SQL SSOT + redb cache)
- Compare read latency: before (sled ~5us) vs after (redb cache ~5us, SQL fallback ~1-10ms)
- Verify CTO revision counter latency unchanged

### 5.5 Type checking & linting
- `ruff check src/nexus/`
- Pyright/mypy on modified files
- `cargo clippy` on Rust changes
- `cargo fmt` on Rust changes

---

## Estimated Effort by Phase

| Phase | Description | Effort |
|-------|-------------|--------|
| 1 | Test Foundation | ~1 day |
| 2 | Python Refactoring | ~1 day |
| 3 | Rust redb Migration | ~2 days |
| 4 | SQL SSOT Consolidation | ~2-3 days |
| 5 | Validation & Cleanup | ~1 day |
| **Total** | | **~7-8 days** |

## Key Risk Mitigations

1. **Phase 1 first** — test safety net before any changes
2. **Phase 2 before Phase 3** — cleaner Python code makes integration easier
3. **Phase 3 preserves API** — RedbStore matches SledStore interface exactly
4. **Phase 4 can be incremental** — start with one metadata operation, expand
5. **Reconciler** catches any consistency drift during transition
6. **Migration tool** — no data loss for existing deployments

## Files Changed Summary

### New Files
- `tests/unit/storage/test_record_store_syncer.py`
- `tests/unit/core/test_audit_strict_mode.py`
- `tests/unit/core/test_write_observer_calls.py`
- `tests/integration/test_dual_write_consistency.py`
- `rust/nexus_raft/src/storage/redb_store.rs`
- `rust/nexus_raft/src/bin/migrate_sled_to_redb.rs`
- `src/nexus/storage/sql_metadata_store.py`
- `src/nexus/storage/reconciler.py`

### Modified Files
- `src/nexus/core/nexus_fs_core.py` (Phases 2-4)
- `src/nexus/core/nexus_fs.py` (Phase 2.3)
- `src/nexus/storage/operation_logger.py` (Phase 2.4)
- `src/nexus/storage/record_store_syncer.py` (Phase 2.4, then removed Phase 4.5)
- `src/nexus/factory.py` (Phase 4.3)
- `rust/nexus_raft/Cargo.toml` (Phase 3.7)
- `rust/nexus_raft/src/raft/state_machine.rs` (Phases 3.2, 3.4, 3.6)
- `rust/nexus_raft/src/raft/storage.rs` (Phase 3.5)
- `rust/nexus_raft/src/pyo3_bindings.rs` (Phase 3.8)
- `rust/nexus_raft/src/storage/mod.rs` (Phase 3.1)

### Removed Files
- `rust/nexus_raft/src/storage/sled_store.rs` (replaced by redb_store.rs)
- `src/nexus/storage/record_store_syncer.py` (Phase 4.5, after consolidation)
