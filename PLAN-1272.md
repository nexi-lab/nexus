# Implementation Plan: #1272 MCP Tool-Level Namespace — Per-Tool ReBAC Grants

## Decided Architecture (All Approved)

| Decision | Choice | Rationale |
|----------|--------|-----------|
| 1. Tool namespace model | **Unified `/tools/` prefix** — tools are paths in existing namespace | Zero DRY, 3-layer cache for free, "namespace is security" principle |
| 2. Filtering boundary | **FastMCP middleware** — filter `tools/list` + validate `tools/call` | Centralized, can't miss a tool. Two-layer defense (MiniScope) |
| 3. Tool profiles | **Hybrid config + ReBAC** — profiles in YAML, grants in ReBAC | Config is policy, ReBAC is enforcement. Matches Cerbos/Progent |
| 4. Invocation security | **Middleware-only enforcement** | Centralized middleware intercepts both list and call messages |
| 5. DRY fix | **Extract `@nexus_tool` decorator** | ~30 lines eliminates ~500 lines boilerplate |
| 6. File split | **Extract middleware.py + profiles.py** from server.py | Minimal churn, keeps tool functions in place |
| 7. Error messages | **Standardized error envelope** | namespace-as-security: invisible = not_found |
| 8. Discovery filtering | **Post-filter ToolIndex results** through namespace | Keeps ToolIndex as pure search, adds permission at call site |
| 9. Testing approach | **Tests alongside implementation** (~52 new tests) | Per-component TDD, covers profiles/grants/middleware/E2E |
| 10. E2E testing | **Real MCP E2E with NexusFS + ReBAC** + timing assertions | Catches integration bugs, <10ms assertion for tool filtering |
| 11. Tool visibility semantics | **Coarse mount table + fine-grained rebac_check** | Mount table = "has ANY tool access", middleware = exact tool check |
| 12. Authorization perf | **Session-start batch + local cache** | rebac_list_objects() filtered to /tools/, cached with revision quantization |
| 13. Profile resolution | **Eager resolution + batch grant write** at agent creation | One-time cost, keeps tools/list hot path fast |
| 14. Context pressure | **Filter only** — no artificial tool cap | Well-designed profiles stay in 15-30 tool sweet spot |
| 15. Query efficiency | **Client-side /tools/ prefix filter** | Optimize with SQL prefix filter later if needed |

---

## Implementation Phases

### Phase 1: Tool Profile Config + ReBAC Grant Generation
**New files:**
- `src/nexus/mcp/profiles.py` — Tool profile dataclass, YAML loader, inheritance resolver
- `tests/unit/mcp/test_tool_profiles.py` — ~14 tests

**Changes:**
- None to existing files yet

**Details:**
```python
# profiles.py

@dataclass(frozen=True)
class ToolProfile:
    name: str
    tools: frozenset[str]           # Resolved tool names
    extends: str | None = None      # Parent profile name
    description: str = ""

@dataclass(frozen=True)
class ToolProfileConfig:
    profiles: dict[str, ToolProfile]  # name → resolved profile
    default_profile: str = "minimal"

def load_profiles(config_path: Path) -> ToolProfileConfig:
    """Load + resolve inheritance from YAML config."""

def resolve_inheritance(raw: dict) -> dict[str, ToolProfile]:
    """Flatten inheritance chains. Cycle detection included."""

def grant_tools_for_profile(
    rebac_manager: EnhancedReBACManager,
    subject: tuple[str, str],
    profile: ToolProfile,
    zone_id: str | None = None,
) -> list[WriteResult]:
    """Batch-write ReBAC grants: (subject, viewer, ("file", "/tools/{tool}"))."""

def revoke_tools_for_profile(
    rebac_manager: EnhancedReBACManager,
    subject: tuple[str, str],
    profile: ToolProfile,
    zone_id: str | None = None,
) -> None:
    """Revoke all tool grants for a profile."""
```

**Test matrix (~14 tests):**
- Load minimal profile from YAML
- Load profile with inheritance (coding extends minimal)
- Deep inheritance (3+ levels)
- Cycle detection raises error
- Missing parent profile raises error
- Default profile selection
- grant_tools_for_profile writes correct tuples
- revoke_tools_for_profile removes correct tuples
- Profile with zero tools
- Profile tool deduplication
- Unknown tool in profile (warning, not error)
- Profile override (agent-specific tools on top of profile)
- YAML syntax error handling
- Config file not found handling

### Phase 2: FastMCP Middleware — Tool Filtering + Invocation Validation
**New files:**
- `src/nexus/mcp/middleware.py` — ToolNamespaceMiddleware
- `tests/unit/mcp/test_tool_namespace_middleware.py` — ~14 tests

**Changes:**
- `src/nexus/mcp/server.py` — Wire middleware, add `namespace_manager` param to `create_mcp_server()`

**Details:**
```python
# middleware.py

class ToolNamespaceMiddleware(Middleware):
    """Filter tools/list by namespace + validate tools/call invocations.

    Two-layer defense (MiniScope pattern):
    1. tools/list: remove invisible tools from response
    2. tools/call: reject invocation of invisible tools
    """

    def __init__(
        self,
        rebac_manager: EnhancedReBACManager,
        zone_id: str | None = None,
        cache_ttl: int = 300,
        revision_window: int = 10,
    ) -> None:
        self._rebac_manager = rebac_manager
        self._zone_id = zone_id
        # Session cache: (subject, zone_id, revision_bucket) → frozenset[str]
        self._tool_cache: TTLCache[tuple, frozenset[str]] = TTLCache(
            maxsize=10_000, ttl=cache_ttl
        )
        self._revision_window = revision_window

    async def on_message(self, context: MiddlewareContext, call_next) -> Any:
        """Intercept tools/list and tools/call MCP messages."""

    def _get_visible_tools(self, subject: tuple[str, str]) -> frozenset[str]:
        """Batch lookup: rebac_list_objects filtered to /tools/ prefix.
        Cached with revision quantization."""

    def _filter_tools_list(self, tools: list, visible: frozenset[str]) -> list:
        """Remove invisible tools from tools/list response."""

    def _validate_tool_call(self, tool_name: str, visible: frozenset[str]) -> None:
        """Raise ToolNotFoundError if tool is not in visible set."""
```

**Test matrix (~14 tests):**
- tools/list returns only visible tools
- tools/list with no grants returns empty list
- tools/list with all grants returns full list
- tools/call succeeds for visible tool
- tools/call fails for invisible tool (returns not_found error)
- tools/call error message doesn't leak "permission denied"
- Cache hit on second tools/list call (no DB query)
- Cache invalidation on revision bucket change
- Subject extraction from context (API key → subject)
- No subject in context → all tools visible (backward compat / admin)
- Concurrent tools/list from different subjects
- Tool added after cache warm → visible after cache TTL
- Tool removed after cache warm → invisible after cache TTL
- Timing assertion: filtering 50 tools < 5ms

### Phase 3: Error Envelope + @nexus_tool Decorator
**New file content (added to middleware.py or new file):**
- Error envelope helper function
- `@nexus_tool` decorator

**Changes:**
- `src/nexus/mcp/server.py` — Replace boilerplate with decorator (mechanical refactor)

**Details:**
```python
# In middleware.py or server.py

@dataclass(frozen=True)
class ToolError:
    category: str  # "not_found", "permission_denied", "invalid_input", "internal"
    message: str   # User-facing message

def tool_error(category: str, message: str, detail: str | None = None) -> str:
    """Standardized error response. Detail is logged, not returned."""
    if detail:
        logger.warning("[TOOL-ERROR] %s: %s — %s", category, message, detail)
    return f"Error: {message}"

def nexus_tool(annotations: dict | None = None):
    """Decorator for MCP tool functions.
    Handles: _get_nexus_instance(), error catching, logging."""
```

**Test matrix (~8 tests):**
- Decorator injects nx_instance correctly
- FileNotFoundError → "not found" category
- PermissionError → "permission denied" category (but namespace replaces with "not found")
- Generic Exception → "internal" category, detail logged
- Error message doesn't include stack trace
- Decorator preserves function signature (for FastMCP introspection)
- Decorator works with and without ctx parameter
- Tool error logging includes request_id

### Phase 4: Discovery Integration (ToolIndex Post-Filter)
**Changes:**
- `src/nexus/mcp/server.py` — Modify `nexus_discovery_search_tools`, `nexus_discovery_list_servers`, `nexus_discovery_load_tools` to post-filter through namespace

**Details:**
```python
# In server.py discovery tools section

@mcp.tool(...)
def nexus_discovery_search_tools(query: str, top_k: int = 5, ctx=None) -> str:
    # Over-fetch to account for filtered results
    matches = tool_index.search(query, top_k=top_k * 3)
    # Post-filter through namespace
    visible = _get_visible_tools_for_context(ctx)
    filtered = [m for m in matches if m.tool.name in visible][:top_k]
    ...
```

**Test matrix (~5 tests):**
- Search returns only visible tools
- Search with all tools invisible returns empty
- Over-fetch compensates for filtering (still returns top_k results)
- list_servers only shows servers with at least one visible tool
- load_tools rejects invisible tool names

### Phase 5: Factory Wiring + Default Profile Config
**Changes:**
- `src/nexus/factory.py` — Wire ToolNamespaceMiddleware into service creation
- `src/nexus/mcp/server.py` — Accept and wire middleware in `create_mcp_server()`
- New file: `src/nexus/config/tool_profiles.yaml` — Default profile definitions

**Details:**
```yaml
# tool_profiles.yaml
profiles:
  minimal:
    description: "Read-only file access"
    tools:
      - nexus_read_file
      - nexus_list_files
      - nexus_file_info
      - nexus_glob

  coding:
    extends: minimal
    description: "File operations for coding agents"
    tools:
      - nexus_write_file
      - nexus_edit_file
      - nexus_delete_file
      - nexus_mkdir
      - nexus_rmdir
      - nexus_rename_file
      - nexus_grep

  search:
    extends: minimal
    description: "Search and memory operations"
    tools:
      - nexus_grep
      - nexus_semantic_search
      - nexus_store_memory
      - nexus_query_memory

  execution:
    extends: coding
    description: "Code execution (requires sandbox)"
    tools:
      - nexus_python
      - nexus_bash
      - nexus_sandbox_create
      - nexus_sandbox_list
      - nexus_sandbox_stop

  full:
    extends: execution
    description: "All tools (admin/development)"
    tools:
      - nexus_semantic_search
      - nexus_store_memory
      - nexus_query_memory
      - nexus_list_workflows
      - nexus_execute_workflow
      - nexus_discovery_search_tools
      - nexus_discovery_list_servers
      - nexus_discovery_get_tool_details
      - nexus_discovery_load_tools

default_profile: minimal
```

**Test matrix (~6 tests):**
- Factory creates middleware when rebac_manager is available
- Factory skips middleware when rebac_manager is None
- Default profiles load correctly
- create_mcp_server accepts namespace params
- Server with middleware filters tools
- Server without middleware returns all tools (backward compat)

### Phase 6: E2E Tests
**New files:**
- `tests/e2e/test_mcp_tool_namespace_e2e.py` — ~5 tests
- `tests/integration/mcp/test_tool_namespace_integration.py` — ~5 tests

**E2E test matrix (~5 tests):**
1. Full flow: create agent → assign "coding" profile → grant tools → tools/list returns only coding tools
2. Profile change: switch from "coding" to "minimal" → tools/list shrinks
3. Invisible tool invocation: agent calls nexus_python without execution profile → "not found"
4. Admin bypass: admin agent sees all tools regardless of profile
5. Timing: tool filtering for 30 tools completes in <10ms

**Integration test matrix (~5 tests):**
1. Two agents with different profiles see different tools
2. Tool grant revocation → tool disappears from tools/list
3. Cache invalidation on rebac_write
4. Concurrent agents don't see each other's tools
5. Profile inheritance resolution matches expected tool set

---

## File Change Summary

| File | Action | Lines (est.) |
|------|--------|-------------|
| `src/nexus/mcp/profiles.py` | **NEW** | ~180 |
| `src/nexus/mcp/middleware.py` | **NEW** | ~200 |
| `src/nexus/config/tool_profiles.yaml` | **NEW** | ~50 |
| `src/nexus/mcp/server.py` | MODIFY (wire middleware, decorator refactor) | ~-300, +80 |
| `src/nexus/factory.py` | MODIFY (wire middleware) | ~+30 |
| `tests/unit/mcp/test_tool_profiles.py` | **NEW** | ~350 |
| `tests/unit/mcp/test_tool_namespace_middleware.py` | **NEW** | ~400 |
| `tests/unit/mcp/test_tool_error_envelope.py` | **NEW** | ~120 |
| `tests/unit/mcp/test_discovery_filtered.py` | **NEW** | ~150 |
| `tests/integration/mcp/test_tool_namespace_integration.py` | **NEW** | ~200 |
| `tests/e2e/test_mcp_tool_namespace_e2e.py` | **NEW** | ~250 |
| **Total new code** | | **~1,710** |
| **Total new tests** | | **~1,470 (~52 tests)** |
| **Net change to server.py** | | **~-220 (shrinks)** |

## Implementation Order

1. **Phase 1** (profiles.py + tests) — No existing code changes, pure addition
2. **Phase 2** (middleware.py + tests) — Core feature, minimal existing code changes
3. **Phase 3** (decorator + error envelope) — Refactor server.py, mechanical changes
4. **Phase 4** (discovery integration) — Small changes to existing discovery tools
5. **Phase 5** (factory wiring + config) — Integration point
6. **Phase 6** (E2E tests) — Final validation with real NexusFS + permissions

## Commit Plan

```
feat(#1272): add tool profile config + YAML loader + inheritance resolver
feat(#1272): add ToolNamespaceMiddleware — tools/list filter + tools/call validation
refactor(#1272): extract @nexus_tool decorator + standardize error envelope
feat(#1272): integrate tool namespace filter into discovery tools
feat(#1272): wire ToolNamespaceMiddleware into factory + create_mcp_server
test(#1272): add MCP tool namespace E2E + integration tests
```
