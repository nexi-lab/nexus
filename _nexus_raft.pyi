"""Type stubs for _nexus_raft PyO3 extension module.

SSOT: rust/nexus_raft/src/pyo3_bindings.rs
Update this file when adding/changing #[pymethods] in the Rust source.
"""

class HolderInfo:
    lock_id: str
    holder_info: str
    acquired_at: int
    expires_at: int

class LockState:
    acquired: bool
    current_holders: int
    max_holders: int
    holders: list[HolderInfo]

class LockInfo:
    path: str
    max_holders: int
    holders: list[HolderInfo]

class Metastore:
    def __init__(self, path: str) -> None: ...
    def next_index(self) -> int: ...
    def last_applied_index(self) -> int: ...
    def set_metadata(self, path: str, value: bytes, consistency: str = "sc") -> int | None: ...
    def get_metadata(self, path: str) -> bytes | None: ...
    def delete_metadata(self, path: str, consistency: str = "sc") -> int | None: ...
    def is_committed(self, token: int) -> str | None: ...
    def list_metadata(self, prefix: str) -> list[tuple[str, bytes]]: ...
    def batch_set_metadata(self, items: list[tuple[str, bytes]]) -> int: ...
    def batch_delete_metadata(self, keys: list[str]) -> int: ...
    def count_metadata(self, prefix: str) -> int: ...
    def acquire_lock(
        self,
        path: str,
        lock_id: str,
        max_holders: int = 1,
        ttl_secs: int = 30,
        holder_info: str = "",
    ) -> LockState: ...
    def release_lock(self, path: str, lock_id: str) -> bool: ...
    def extend_lock(self, path: str, lock_id: str, new_ttl_secs: int) -> bool: ...
    def get_lock(self, path: str) -> LockInfo | None: ...
    def list_locks(self, prefix: str, limit: int) -> list[LockInfo]: ...
    def force_release_lock(self, path: str) -> bool: ...
    def increment_revision(self, zone_id: str) -> int: ...
    def get_revision(self, zone_id: str) -> int: ...
    def snapshot(self) -> bytes: ...
    def restore_snapshot(self, data: bytes) -> None: ...
    def flush(self) -> None: ...

class ZoneManager:
    def __init__(
        self,
        node_id: int,
        base_path: str,
        bind_addr: str = "0.0.0.0:2126",
        tls_cert_path: str | None = None,
        tls_key_path: str | None = None,
        tls_ca_path: str | None = None,
    ) -> None: ...
    def create_zone(self, zone_id: str, peers: list[str] | None = None) -> ZoneHandle: ...
    def join_zone(self, zone_id: str, peers: list[str] | None = None) -> ZoneHandle: ...
    def get_zone(self, zone_id: str) -> ZoneHandle | None: ...
    def remove_zone(self, zone_id: str) -> None: ...
    def list_zones(self) -> list[str]: ...
    def node_id(self) -> int: ...
    def shutdown(self) -> None: ...

class ZoneHandle:
    def zone_id(self) -> str: ...
    def set_metadata(self, path: str, value: bytes, consistency: str = "sc") -> int | None: ...
    def get_metadata(self, path: str) -> bytes | None: ...
    def delete_metadata(self, path: str, consistency: str = "sc") -> int | None: ...
    def is_committed(self, token: int) -> str | None: ...
    def list_metadata(self, prefix: str) -> list[tuple[str, bytes]]: ...
    def acquire_lock(
        self,
        path: str,
        lock_id: str,
        max_holders: int = 1,
        ttl_secs: int = 30,
        holder_info: str = "",
    ) -> LockState: ...
    def release_lock(self, path: str, lock_id: str) -> bool: ...
    def extend_lock(self, path: str, lock_id: str, new_ttl_secs: int) -> bool: ...
    def get_lock(self, path: str) -> LockInfo | None: ...
    def list_locks(self, prefix: str = "", limit: int = 1000) -> list[LockInfo]: ...
    def is_leader(self) -> bool: ...
    def leader_id(self) -> int | None: ...
