#!/usr/bin/env python3
"""Generate Python dataclasses from proto/nexus/core/metadata.proto.

SSOT: proto/nexus/core/metadata.proto is the single source of truth
for FileMetadata fields. This script generates:

  - src/nexus/core/_metadata_generated.py  (FileMetadata + PaginatedResult + MetadataStore ABC)
  - src/nexus/core/_compact_generated.py   (CompactFileMetadata + interning)

Usage:
    python scripts/gen_metadata.py
"""

from __future__ import annotations

import re
import sys
from pathlib import Path

# Resolve paths relative to repo root
REPO_ROOT = Path(__file__).resolve().parent.parent
PROTO_PATH = REPO_ROOT / "proto" / "nexus" / "core" / "metadata.proto"
METADATA_OUT = REPO_ROOT / "src" / "nexus" / "core" / "_metadata_generated.py"
COMPACT_OUT = REPO_ROOT / "src" / "nexus" / "core" / "_compact_generated.py"

# --- Proto field configuration ---
# When you add a field to metadata.proto, update these mappings.

# Proto type -> Python type
PROTO_TYPE_MAP: dict[str, str] = {
    "string": "str",
    "int64": "int",
    "int32": "int",
    "bool": "bool",
}

# Fields where Python uses datetime | None instead of str
DATETIME_FIELDS: set[str] = {"created_at", "modified_at"}

# String fields that are nullable (str | None, default None)
NULLABLE_STRING_FIELDS: set[str] = {
    "etag",
    "mime_type",
    "zone_id",
    "created_by",
    "owner_id",
}

# Non-default defaults
FIELD_DEFAULTS: dict[str, str] = {
    "version": "1",
    "is_directory": "False",
}

# String fields that get interned in CompactFileMetadata
INTERNED_FIELDS: list[str] = [
    "path",
    "backend_name",
    "physical_path",
    "etag",
    "mime_type",
    "zone_id",
    "created_by",
    "owner_id",
]

# Compact field name mapping
COMPACT_FIELD_NAMES: dict[str, str] = {
    "path": "path_id",
    "backend_name": "backend_name_id",
    "physical_path": "physical_path_id",
    "etag": "etag_id",
    "mime_type": "mime_type_id",
    "zone_id": "zone_id_intern",
    "created_by": "created_by_id",
    "owner_id": "owner_id_intern",
}


# --- Proto parser ---


def parse_proto_fields(proto_path: Path) -> list[dict[str, str]]:
    """Parse FileMetadata fields from proto file.

    Returns list of dicts with keys: name, type, number, comment.
    """
    content = proto_path.read_text(encoding="utf-8")

    match = re.search(r"message\s+FileMetadata\s*\{(.*?)\}", content, re.DOTALL)
    if not match:
        print("ERROR: Could not find 'message FileMetadata' in proto file", file=sys.stderr)
        sys.exit(1)

    body = match.group(1)
    fields = []

    field_re = re.compile(r"^\s*(\w+)\s+(\w+)\s*=\s*(\d+)\s*;(?:\s*//\s*(.*))?$", re.MULTILINE)

    lines = body.split("\n")
    prev_comment = ""
    for line in lines:
        stripped = line.strip()
        if stripped.startswith("//"):
            prev_comment = stripped.lstrip("/ ").strip()
            continue

        m = field_re.match(line)
        if m:
            inline_comment = m.group(4) or ""
            comment = inline_comment or prev_comment
            fields.append(
                {
                    "type": m.group(1),
                    "name": m.group(2),
                    "number": m.group(3),
                    "comment": comment,
                }
            )
            prev_comment = ""
        elif stripped:
            prev_comment = ""

    return fields


# --- Code generators ---


def python_type_for(field: dict[str, str]) -> str:
    """Get Python type annotation for a proto field."""
    name = field["name"]
    if name in DATETIME_FIELDS:
        return "datetime | None"
    base_type = PROTO_TYPE_MAP.get(field["type"], field["type"])
    if name in NULLABLE_STRING_FIELDS:
        return f"{base_type} | None"
    return base_type


def python_default_for(field: dict[str, str]) -> str | None:
    """Get Python default value, or None if no default."""
    name = field["name"]
    if name in FIELD_DEFAULTS:
        return FIELD_DEFAULTS[name]
    if name in DATETIME_FIELDS or name in NULLABLE_STRING_FIELDS:
        return "None"
    return None


def generate_metadata_py(fields: list[dict[str, str]]) -> str:
    """Generate _metadata_generated.py content."""
    # Build field lines
    field_lines = []
    for f in fields:
        py_type = python_type_for(f)
        default = python_default_for(f)

        if default is not None:
            line = f"    {f['name']}: {py_type} = {default}"
        else:
            line = f"    {f['name']}: {py_type}"

        field_lines.append(line)

    fields_block = "\n".join(field_lines)

    return f'''\
"""Auto-generated from proto/nexus/core/metadata.proto - DO NOT EDIT.

This module is generated by: python scripts/gen_metadata.py
SSOT: proto/nexus/core/metadata.proto

To modify FileMetadata:
  1. Edit proto/nexus/core/metadata.proto
  2. Run: python scripts/gen_metadata.py
  3. Never edit this file directly!

Contains:
  - FileMetadata: Core file metadata dataclass
  - PaginatedResult: Cursor-based pagination container
  - MetadataStore: Abstract base class for metadata storage backends
"""

from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import Sequence
from dataclasses import dataclass
from datetime import datetime
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from nexus.core._compact_generated import CompactFileMetadata


@dataclass
class PaginatedResult:
    """Result container for paginated list operations.

    Generated from: proto/nexus/core/metadata.proto

    Supports cursor-based pagination for efficient traversal of large datasets
    at 1M+ file scale without OOM or timeouts.

    Attributes:
        items: List of FileMetadata or dict items for current page
        next_cursor: Opaque token for fetching next page (None if last page)
        has_more: Whether more results exist beyond this page
        total_count: Optional total count (expensive at scale, often None)
    """

    items: list[Any]
    next_cursor: str | None
    has_more: bool
    total_count: int | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to JSON-serializable dict for API response."""
        return {{
            "items": self.items,
            "next_cursor": self.next_cursor,
            "has_more": self.has_more,
            "total_count": self.total_count,
        }}


@dataclass(slots=True)
class FileMetadata:
    """File metadata information.

    Generated from: proto/nexus/core/metadata.proto
    """

{fields_block}

    def validate(self) -> None:
        """Validate file metadata before database operations.

        Raises:
            ValidationError: If validation fails with clear message.
        """
        from nexus.core.exceptions import ValidationError

        if not self.path:
            raise ValidationError("path is required")

        if not self.path.startswith("/"):
            raise ValidationError(f"path must start with '/', got {{self.path!r}}", path=self.path)

        if "\\x00" in self.path:
            raise ValidationError("path contains null bytes", path=self.path)

        if not self.backend_name:
            raise ValidationError("backend_name is required", path=self.path)

        if not self.physical_path:
            raise ValidationError("physical_path is required", path=self.path)

        if self.size < 0:
            raise ValidationError(f"size cannot be negative, got {{self.size}}", path=self.path)

        if self.version < 1:
            raise ValidationError(f"version must be >= 1, got {{self.version}}", path=self.path)

    def to_compact(self) -> CompactFileMetadata:
        """Convert to memory-efficient CompactFileMetadata.

        Uses string interning to deduplicate path/hash strings across instances.
        Reduces memory from ~200-300 bytes to ~64-100 bytes per instance.

        Returns:
            CompactFileMetadata with interned strings and packed fields
        """
        from nexus.core._compact_generated import CompactFileMetadata

        return CompactFileMetadata.from_file_metadata(self)

    @classmethod
    def from_compact(cls, compact: CompactFileMetadata) -> FileMetadata:
        """Create FileMetadata from CompactFileMetadata.

        Resolves interned string IDs back to full strings.

        Args:
            compact: CompactFileMetadata instance

        Returns:
            Full FileMetadata object
        """
        return compact.to_file_metadata()


class MetadataStore(ABC):
    """Abstract interface for metadata storage.

    Generated from: proto/nexus/core/metadata.proto

    Stores mapping between virtual paths and backend physical locations.
    All storage backends (SQLAlchemy, Raft, etc.) implement this interface.
    """

    @abstractmethod
    def get(self, path: str) -> FileMetadata | None:
        """Get metadata for a file."""
        pass

    @abstractmethod
    def put(self, metadata: FileMetadata) -> None:
        """Store or update file metadata."""
        pass

    @abstractmethod
    def delete(self, path: str) -> dict[str, Any] | None:
        """Delete file metadata. Returns deleted file info or None."""
        pass

    @abstractmethod
    def exists(self, path: str) -> bool:
        """Check if metadata exists for a path."""
        pass

    @abstractmethod
    def list(self, prefix: str = "", recursive: bool = True) -> list[FileMetadata]:
        """List all files with given path prefix."""
        pass

    def list_paginated(
        self,
        prefix: str = "",
        recursive: bool = True,
        limit: int = 1000,
        cursor: str | None = None,  # noqa: ARG002
        zone_id: str | None = None,  # noqa: ARG002
    ) -> PaginatedResult:
        """List files with cursor-based pagination.

        Uses keyset pagination for O(log n) performance regardless of page depth.
        """
        all_items = self.list(prefix, recursive)
        return PaginatedResult(
            items=all_items[:limit],
            next_cursor=None,
            has_more=len(all_items) > limit,
            total_count=len(all_items),
        )

    def get_batch(self, paths: Sequence[str]) -> dict[str, FileMetadata | None]:
        """Get metadata for multiple files in a single query."""
        return {{path: self.get(path) for path in paths}}

    def delete_batch(self, paths: Sequence[str]) -> None:
        """Delete multiple files in a single transaction."""
        for path in paths:
            self.delete(path)

    def put_batch(self, metadata_list: Sequence[FileMetadata]) -> None:
        """Store or update multiple file metadata entries in a single transaction."""
        for metadata in metadata_list:
            self.put(metadata)

    def batch_get_content_ids(self, paths: Sequence[str]) -> dict[str, str | None]:
        """Get content IDs (hashes) for multiple paths in a single query."""
        result: dict[str, str | None] = {{}}
        for path in paths:
            metadata = self.get(path)
            result[path] = metadata.etag if metadata else None
        return result

    @abstractmethod
    def close(self) -> None:
        """Close the metadata store and release resources."""
        pass
'''


def generate_compact_py(fields: list[dict[str, str]]) -> str:
    """Generate _compact_generated.py content."""
    # Build CompactFileMetadata field declarations
    compact_field_lines = []
    for f in fields:
        name = f["name"]
        if name in COMPACT_FIELD_NAMES:
            cname = COMPACT_FIELD_NAMES[name]
            compact_field_lines.append(f"    {cname}: int")
        elif name in DATETIME_FIELDS:
            compact_field_lines.append(f"    {name}: str | None")
        elif name == "size":
            compact_field_lines.append("    size: int")
        elif name == "version":
            compact_field_lines.append("    version: int")
        elif name == "is_directory":
            compact_field_lines.append("    is_directory: bool")
    compact_fields_block = "\n".join(compact_field_lines)

    # Build from_file_metadata keyword args
    ctor_args = []
    for f in fields:
        name = f["name"]
        if name in COMPACT_FIELD_NAMES:
            cname = COMPACT_FIELD_NAMES[name]
            ctor_args.append(f"            {cname}=_intern(m.{name}),")
        elif name in DATETIME_FIELDS:
            ctor_args.append(f"            {name}=m.{name}.isoformat() if m.{name} else None,")
        elif name in ("size", "version", "is_directory"):
            ctor_args.append(f"            {name}=m.{name},")
    ctor_block = "\n".join(ctor_args)

    # Build to_file_metadata keyword args
    # Required string fields use _resolve_required() for type safety
    required_string_fields = {n for n in COMPACT_FIELD_NAMES if n not in NULLABLE_STRING_FIELDS}
    fm_args = []
    for f in fields:
        name = f["name"]
        if name in COMPACT_FIELD_NAMES:
            cname = COMPACT_FIELD_NAMES[name]
            if name in required_string_fields:
                fm_args.append(f"            {name}=_resolve_required(self.{cname}),")
            else:
                fm_args.append(f"            {name}=_resolve(self.{cname}),")
        elif name in DATETIME_FIELDS:
            fm_args.append(
                f"            {name}=datetime.fromisoformat(self.{name}) if self.{name} else None,"
            )
        elif name in ("size", "version", "is_directory"):
            fm_args.append(f"            {name}=self.{name},")
    fm_block = "\n".join(fm_args)

    return f'''\
"""Auto-generated from proto/nexus/core/metadata.proto - DO NOT EDIT.

This module is generated by: python scripts/gen_metadata.py
SSOT: proto/nexus/core/metadata.proto

Compact file metadata for memory-efficient storage at scale.

String fields are stored as integer IDs (4 bytes each) instead of
full string objects. This reduces memory from ~200-300 bytes to
~64-100 bytes per file at 1M+ file scale.

Timestamps are stored as ISO 8601 strings to preserve precision
and timezone information across serialization boundaries.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from nexus.core._metadata_generated import FileMetadata

# --- String interning ---
# Single global pool: string -> int ID, and reverse lookup.
# All string fields share one pool for simplicity.

_STRING_POOL: dict[str, int] = {{}}
_STRING_POOL_REVERSE: dict[int, str] = {{}}
_NEXT_ID: int = 0


def _intern(s: str | None) -> int:
    """Intern a string and return its ID. Returns -1 for None."""
    global _NEXT_ID
    if s is None:
        return -1
    if s not in _STRING_POOL:
        _STRING_POOL[s] = _NEXT_ID
        _STRING_POOL_REVERSE[_NEXT_ID] = s
        _NEXT_ID += 1
    return _STRING_POOL[s]


def _resolve(id: int) -> str | None:
    """Resolve a string ID back to its value. Returns None for -1."""
    if id == -1:
        return None
    return _STRING_POOL_REVERSE.get(id)


def _resolve_required(id: int) -> str:
    """Resolve a required string field. Raises if not found."""
    result = _STRING_POOL_REVERSE.get(id)
    if result is None:
        raise ValueError(f"Interned string ID {{id}} not found in pool")
    return result


@dataclass(frozen=True)
class CompactFileMetadata:
    """Memory-optimized FileMetadata using string interning.

    Generated from: proto/nexus/core/metadata.proto

    String fields are stored as integer IDs (4 bytes each) instead of
    full string objects. This reduces per-instance memory significantly.
    """

{compact_fields_block}

    @classmethod
    def from_file_metadata(cls, m: FileMetadata) -> CompactFileMetadata:
        """Create CompactFileMetadata from FileMetadata."""
        return cls(
{ctor_block}
        )

    def to_file_metadata(self) -> FileMetadata:
        """Convert back to FileMetadata."""
        from nexus.core._metadata_generated import FileMetadata

        return FileMetadata(
{fm_block}
        )


def get_intern_pool_stats() -> dict[str, int]:
    """Get string interning pool statistics."""
    return {{
        "count": len(_STRING_POOL),
        "memory_estimate": sum(len(s) for s in _STRING_POOL) + len(_STRING_POOL) * 100,
    }}


def clear_intern_pool() -> None:
    """Clear the intern pool. Use only for testing."""
    global _NEXT_ID
    _STRING_POOL.clear()
    _STRING_POOL_REVERSE.clear()
    _NEXT_ID = 0
'''


def main() -> None:
    """Parse proto and generate Python files."""
    if not PROTO_PATH.exists():
        print(f"ERROR: Proto file not found: {PROTO_PATH}", file=sys.stderr)
        sys.exit(1)

    fields = parse_proto_fields(PROTO_PATH)
    if not fields:
        print("ERROR: No fields found in FileMetadata message", file=sys.stderr)
        sys.exit(1)

    print(f"Parsed {len(fields)} fields from {PROTO_PATH.name}:")
    for f in fields:
        print(f"  {f['type']} {f['name']} = {f['number']}")

    metadata_content = generate_metadata_py(fields)
    METADATA_OUT.write_text(metadata_content, encoding="utf-8")
    print(f"\nGenerated: {METADATA_OUT}")

    compact_content = generate_compact_py(fields)
    COMPACT_OUT.write_text(compact_content, encoding="utf-8")
    print(f"Generated: {COMPACT_OUT}")

    print("\nDone. SSOT: proto/nexus/core/metadata.proto")


if __name__ == "__main__":
    main()
