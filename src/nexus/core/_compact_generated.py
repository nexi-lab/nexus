"""Auto-generated from proto/nexus/core/metadata.proto - DO NOT EDIT.

This module is generated by: python scripts/gen_metadata.py
SSOT: proto/nexus/core/metadata.proto

Compact file metadata for memory-efficient storage at scale.

String fields are stored as integer IDs (4 bytes each) instead of
full string objects. This reduces memory from ~200-300 bytes to
~64-100 bytes per file at 1M+ file scale.

Timestamps are stored as ISO 8601 strings to preserve precision
and timezone information across serialization boundaries.
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from nexus.core._metadata_generated import FileMetadata

# --- String interning ---
# Single global pool: string -> int ID, and reverse lookup.
# All string fields share one pool for simplicity.

_STRING_POOL: dict[str, int] = {}
_STRING_POOL_REVERSE: dict[int, str] = {}
_NEXT_ID: int = 0


def _intern(s: str | None) -> int:
    """Intern a string and return its ID. Returns -1 for None."""
    global _NEXT_ID
    if s is None:
        return -1
    if s not in _STRING_POOL:
        _STRING_POOL[s] = _NEXT_ID
        _STRING_POOL_REVERSE[_NEXT_ID] = s
        _NEXT_ID += 1
    return _STRING_POOL[s]


def _resolve(id: int) -> str | None:
    """Resolve a string ID back to its value. Returns None for -1."""
    if id == -1:
        return None
    return _STRING_POOL_REVERSE.get(id)


def _resolve_required(id: int) -> str:
    """Resolve a required string field. Raises if not found."""
    result = _STRING_POOL_REVERSE.get(id)
    if result is None:
        raise ValueError(f"Interned string ID {id} not found in pool")
    return result


@dataclass(frozen=True)
class CompactFileMetadata:
    """Memory-optimized FileMetadata using string interning.

    Generated from: proto/nexus/core/metadata.proto

    String fields are stored as integer IDs (4 bytes each) instead of
    full string objects. This reduces per-instance memory significantly.
    """

    path_id: int
    backend_name_id: int
    physical_path_id: int
    size: int
    etag_id: int
    mime_type_id: int
    created_at: str | None
    modified_at: str | None
    version: int
    zone_id_intern: int
    created_by_id: int
    owner_id_intern: int
    entry_type: int
    target_zone_id_intern: int
    i_links_count: int

    @classmethod
    def from_file_metadata(cls, m: FileMetadata) -> CompactFileMetadata:
        """Create CompactFileMetadata from FileMetadata."""
        return cls(
            path_id=_intern(m.path),
            backend_name_id=_intern(m.backend_name),
            physical_path_id=_intern(m.physical_path),
            size=m.size,
            etag_id=_intern(m.etag),
            mime_type_id=_intern(m.mime_type),
            created_at=m.created_at.isoformat() if m.created_at else None,
            modified_at=m.modified_at.isoformat() if m.modified_at else None,
            version=m.version,
            zone_id_intern=_intern(m.zone_id),
            created_by_id=_intern(m.created_by),
            owner_id_intern=_intern(m.owner_id),
            entry_type=m.entry_type,
            target_zone_id_intern=_intern(m.target_zone_id),
            i_links_count=m.i_links_count,
        )

    def to_file_metadata(self) -> FileMetadata:
        """Convert back to FileMetadata."""
        from nexus.core._metadata_generated import FileMetadata

        return FileMetadata(
            path=_resolve_required(self.path_id),
            backend_name=_resolve_required(self.backend_name_id),
            physical_path=_resolve_required(self.physical_path_id),
            size=self.size,
            etag=_resolve(self.etag_id),
            mime_type=_resolve(self.mime_type_id),
            created_at=datetime.fromisoformat(self.created_at) if self.created_at else None,
            modified_at=datetime.fromisoformat(self.modified_at) if self.modified_at else None,
            version=self.version,
            zone_id=_resolve(self.zone_id_intern),
            created_by=_resolve(self.created_by_id),
            owner_id=_resolve(self.owner_id_intern),
            entry_type=self.entry_type,
            target_zone_id=_resolve(self.target_zone_id_intern),
            i_links_count=self.i_links_count,
        )


def get_intern_pool_stats() -> dict[str, int]:
    """Get string interning pool statistics."""
    return {
        "count": len(_STRING_POOL),
        "memory_estimate": sum(len(s) for s in _STRING_POOL) + len(_STRING_POOL) * 100,
    }


def clear_intern_pool() -> None:
    """Clear the intern pool. Use only for testing."""
    global _NEXT_ID
    _STRING_POOL.clear()
    _STRING_POOL_REVERSE.clear()
    _NEXT_ID = 0
