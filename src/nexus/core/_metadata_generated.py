"""Auto-generated from proto/nexus/core/metadata.proto - DO NOT EDIT.

This module is generated by: python scripts/gen_metadata.py
SSOT: proto/nexus/core/metadata.proto

To modify FileMetadata:
  1. Edit proto/nexus/core/metadata.proto
  2. Run: python scripts/gen_metadata.py
  3. Never edit this file directly!

Contains:
  - FileMetadata: Core file metadata dataclass
  - PaginatedResult: Cursor-based pagination container
  - FileMetadataProtocol: Abstract base class for metadata storage backends
  - AsyncFileMetadataWrapper: Async wrapper (derived from FileMetadataProtocol)
"""

from __future__ import annotations

import asyncio
from abc import ABC, abstractmethod
from collections.abc import Iterator, Sequence
from dataclasses import dataclass
from datetime import datetime
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from nexus.core._compact_generated import CompactFileMetadata


@dataclass
class PaginatedResult:
    """Result container for paginated list operations.

    Generated from: proto/nexus/core/metadata.proto

    Supports cursor-based pagination for efficient traversal of large datasets
    at 1M+ file scale without OOM or timeouts.

    Attributes:
        items: List of FileMetadata or dict items for current page
        next_cursor: Opaque token for fetching next page (None if last page)
        has_more: Whether more results exist beyond this page
        total_count: Optional total count (expensive at scale, often None)
    """

    items: list[Any]
    next_cursor: str | None
    has_more: bool
    total_count: int | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to JSON-serializable dict for API response."""
        return {
            "items": self.items,
            "next_cursor": self.next_cursor,
            "has_more": self.has_more,
            "total_count": self.total_count,
        }


@dataclass(slots=True)
class FileMetadata:
    """File metadata information.

    Generated from: proto/nexus/core/metadata.proto
    """

    path: str
    backend_name: str
    physical_path: str
    size: int
    etag: str | None = None
    mime_type: str | None = None
    created_at: datetime | None = None
    modified_at: datetime | None = None
    version: int = 1
    zone_id: str | None = None
    created_by: str | None = None
    is_directory: bool = False
    owner_id: str | None = None

    def validate(self) -> None:
        """Validate file metadata before database operations.

        Raises:
            ValidationError: If validation fails with clear message.
        """
        from nexus.core.exceptions import ValidationError

        if not self.path:
            raise ValidationError("path is required")

        if not self.path.startswith("/"):
            raise ValidationError(f"path must start with '/', got {self.path!r}", path=self.path)

        if "\x00" in self.path:
            raise ValidationError("path contains null bytes", path=self.path)

        if not self.backend_name:
            raise ValidationError("backend_name is required", path=self.path)

        if not self.physical_path:
            raise ValidationError("physical_path is required", path=self.path)

        if self.size < 0:
            raise ValidationError(f"size cannot be negative, got {self.size}", path=self.path)

        if self.version < 1:
            raise ValidationError(f"version must be >= 1, got {self.version}", path=self.path)

    def to_compact(self) -> CompactFileMetadata:
        """Convert to memory-efficient CompactFileMetadata.

        Uses string interning to deduplicate path/hash strings across instances.
        Reduces memory from ~200-300 bytes to ~64-100 bytes per instance.

        Returns:
            CompactFileMetadata with interned strings and packed fields
        """
        from nexus.core._compact_generated import CompactFileMetadata

        return CompactFileMetadata.from_file_metadata(self)

    @classmethod
    def from_compact(cls, compact: CompactFileMetadata) -> FileMetadata:
        """Create FileMetadata from CompactFileMetadata.

        Resolves interned string IDs back to full strings.

        Args:
            compact: CompactFileMetadata instance

        Returns:
            Full FileMetadata object
        """
        return compact.to_file_metadata()


class FileMetadataProtocol(ABC):
    """Abstract interface for metadata storage.

    Generated from: proto/nexus/core/metadata.proto

    Stores mapping between virtual paths and backend physical locations.
    All storage backends (SQLAlchemy, Raft, etc.) implement this interface.
    """

    @abstractmethod
    def get(self, path: str) -> FileMetadata | None:
        """Get metadata for a file."""
        pass

    @abstractmethod
    def put(self, metadata: FileMetadata) -> None:
        """Store or update file metadata."""
        pass

    @abstractmethod
    def delete(self, path: str) -> dict[str, Any] | None:
        """Delete file metadata. Returns deleted file info or None."""
        pass

    @abstractmethod
    def exists(self, path: str) -> bool:
        """Check if metadata exists for a path."""
        pass

    @abstractmethod
    def list(self, prefix: str = "", recursive: bool = True, **kwargs: Any) -> list[FileMetadata]:
        """List all files with given path prefix."""
        pass

    def list_iter(
        self,
        prefix: str = "",
        recursive: bool = True,
        **kwargs: Any,
    ) -> Iterator[FileMetadata]:
        """Iterate over file metadata matching prefix.

        Memory-efficient alternative to list(). Yields results one at a time
        instead of materializing the full list in memory.

        Subclasses may override for true streaming from the underlying store.
        The default implementation delegates to list() for backward compatibility.

        Args:
            prefix: Path prefix to match
            recursive: If True, include nested paths
            **kwargs: Additional backend-specific filters

        Yields:
            FileMetadata entries matching the prefix
        """
        yield from self.list(prefix, recursive, **kwargs)

    def list_paginated(
        self,
        prefix: str = "",
        recursive: bool = True,
        limit: int = 1000,
        cursor: str | None = None,  # noqa: ARG002
        zone_id: str | None = None,  # noqa: ARG002
    ) -> PaginatedResult:
        """List files with cursor-based pagination.

        Uses keyset pagination for O(log n) performance regardless of page depth.
        """
        all_items = self.list(prefix, recursive)
        return PaginatedResult(
            items=all_items[:limit],
            next_cursor=None,
            has_more=len(all_items) > limit,
            total_count=len(all_items),
        )

    def get_batch(self, paths: Sequence[str]) -> dict[str, FileMetadata | None]:
        """Get metadata for multiple files in a single query."""
        return {path: self.get(path) for path in paths}

    def delete_batch(self, paths: Sequence[str]) -> None:
        """Delete multiple files in a single transaction."""
        for path in paths:
            self.delete(path)

    def put_batch(self, metadata_list: Sequence[FileMetadata]) -> None:
        """Store or update multiple file metadata entries in a single transaction."""
        for metadata in metadata_list:
            self.put(metadata)

    def batch_get_content_ids(self, paths: Sequence[str]) -> dict[str, str | None]:
        """Get content IDs (hashes) for multiple paths in a single query."""
        result: dict[str, str | None] = {}
        for path in paths:
            metadata = self.get(path)
            result[path] = metadata.etag if metadata else None
        return result

    @abstractmethod
    def close(self) -> None:
        """Close the metadata store and release resources."""
        pass


class AsyncFileMetadataWrapper:
    """Async wrapper around any FileMetadataProtocol implementation.

    Generated from: scripts/gen_metadata.py
    Derived from: FileMetadataProtocol method signatures (SSOT).

    Each ``aXXX(...)`` method delegates to ``asyncio.to_thread(store.XXX, ...)``.
    Performance: sled ~5 us + to_thread ~50 us = 55 us per call.
    """

    def __init__(self, store: FileMetadataProtocol) -> None:
        self._store = store

    async def aget(self, path: str) -> FileMetadata | None:
        return await asyncio.to_thread(self._store.get, path)

    async def aput(self, metadata: FileMetadata) -> None:
        return await asyncio.to_thread(self._store.put, metadata)

    async def adelete(self, path: str) -> dict[str, Any] | None:
        return await asyncio.to_thread(self._store.delete, path)

    async def aexists(self, path: str) -> bool:
        return await asyncio.to_thread(self._store.exists, path)

    async def alist(
        self, prefix: str = "", recursive: bool = True, **kwargs: Any
    ) -> list[FileMetadata]:
        return await asyncio.to_thread(self._store.list, prefix, recursive, **kwargs)

    async def alist_iter(
        self, prefix: str = "", recursive: bool = True, **kwargs: Any
    ) -> list[FileMetadata]:
        """Async list_iter - returns list since async generators need different patterns.

        Delegates to list_iter() in a thread to avoid blocking the event loop.
        Returns a list because async iteration across thread boundaries is complex;
        callers should use alist() or alist_iter() based on their needs.
        """
        return await asyncio.to_thread(
            lambda: list(self._store.list_iter(prefix, recursive, **kwargs))
        )

    async def alist_paginated(
        self,
        prefix: str = "",
        recursive: bool = True,
        limit: int = 1000,
        cursor: str | None = None,
        zone_id: str | None = None,
    ) -> PaginatedResult:
        return await asyncio.to_thread(
            self._store.list_paginated, prefix, recursive, limit, cursor, zone_id
        )

    async def aget_batch(self, paths: Sequence[str]) -> dict[str, FileMetadata | None]:
        return await asyncio.to_thread(self._store.get_batch, paths)

    async def adelete_batch(self, paths: Sequence[str]) -> None:
        return await asyncio.to_thread(self._store.delete_batch, paths)

    async def aput_batch(self, metadata_list: Sequence[FileMetadata]) -> None:
        return await asyncio.to_thread(self._store.put_batch, metadata_list)

    async def abatch_get_content_ids(self, paths: Sequence[str]) -> dict[str, str | None]:
        return await asyncio.to_thread(self._store.batch_get_content_ids, paths)

    async def aclose(self) -> None:
        return await asyncio.to_thread(self._store.close)
