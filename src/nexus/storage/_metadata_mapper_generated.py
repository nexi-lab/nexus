"""Auto-generated from proto/nexus/core/metadata.proto - DO NOT EDIT.

This module is generated by: python scripts/gen_metadata.py
SSOT: proto/nexus/core/metadata.proto

Central metadata mapping between FileMetadata and serialization formats.
Proto/JSON methods are auto-generated. SQL methods are manual (different schema).
"""

from __future__ import annotations

import logging
from contextlib import suppress
from datetime import datetime
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from nexus.core._metadata_generated import FileMetadata

logger = logging.getLogger(__name__)


def _to_naive(dt: datetime | None) -> datetime | None:
    """Strip timezone from datetime (SQLite stores naive UTC)."""
    if dt is None:
        return None
    return dt.replace(tzinfo=None) if dt.tzinfo else dt


def _utcnow_naive() -> datetime:
    """Return current UTC time as naive datetime (for SQLite compat)."""
    from datetime import UTC

    return datetime.now(UTC).replace(tzinfo=None)


# ---------------------------------------------------------------------------
# Field name mapping: proto field -> SQLAlchemy column (manual, not generated)
# ---------------------------------------------------------------------------

PROTO_TO_SQL: dict[str, str | None] = {
    "path": "virtual_path",
    "backend_name": "backend_id",
    "physical_path": "physical_path",
    "size": "size_bytes",
    "etag": "content_hash",
    "mime_type": "file_type",
    "created_at": "created_at",
    "modified_at": "updated_at",
    "version": "current_version",
    "zone_id": "zone_id",
    "created_by": None,  # TODO(#1246): Add to FilePathModel
    "entry_type": None,  # TODO(#1246): Add to FilePathModel
    "target_zone_id": None,  # TODO(#1246): Add to FilePathModel
    "owner_id": "posix_uid",
    "i_links_count": None,  # Metastore-only (mount ref count), not in SQL
}


class MetadataMapper:
    """Centralized mapping between FileMetadata and other representations.

    Proto/JSON methods are auto-generated from proto field definitions.
    SQL methods are manual (different column name mapping).
    """

    # -- Proto serialization (GENERATED) ------------------------------------

    @staticmethod
    def to_proto(metadata: FileMetadata) -> Any:
        """Convert FileMetadata dataclass to protobuf message."""
        from nexus.core import metadata_pb2

        return metadata_pb2.FileMetadata(
            path=metadata.path,
            backend_name=metadata.backend_name,
            physical_path=metadata.physical_path or "",
            size=metadata.size,
            etag=metadata.etag or "",
            mime_type=metadata.mime_type or "",
            created_at=metadata.created_at.isoformat() if metadata.created_at else "",
            modified_at=metadata.modified_at.isoformat() if metadata.modified_at else "",
            version=metadata.version,
            zone_id=metadata.zone_id or "",
            created_by=metadata.created_by or "",
            owner_id=metadata.owner_id or "",
            entry_type=metadata_pb2.DirEntryType.Name(metadata.entry_type),
            target_zone_id=metadata.target_zone_id or "",
            i_links_count=metadata.i_links_count,
        )

    @staticmethod
    def from_proto(proto: Any) -> FileMetadata:
        """Convert protobuf message to FileMetadata dataclass."""
        from nexus.core._metadata_generated import FileMetadata

        created_at = None
        if proto.created_at:
            with suppress(ValueError):
                created_at = datetime.fromisoformat(proto.created_at)
        modified_at = None
        if proto.modified_at:
            with suppress(ValueError):
                modified_at = datetime.fromisoformat(proto.modified_at)

        return FileMetadata(
            path=proto.path,
            backend_name=proto.backend_name,
            physical_path=proto.physical_path or proto.path,
            size=proto.size,
            etag=proto.etag or None,
            mime_type=proto.mime_type or None,
            created_at=created_at,
            modified_at=modified_at,
            version=proto.version,
            zone_id=proto.zone_id or None,
            created_by=proto.created_by or None,
            owner_id=proto.owner_id or None,
            entry_type=proto.entry_type,
            target_zone_id=proto.target_zone_id or None,
            i_links_count=proto.i_links_count,
        )

    # -- JSON serialization (GENERATED) -------------------------------------

    @staticmethod
    def to_json(metadata: FileMetadata) -> dict[str, Any]:
        """Convert FileMetadata to JSON-serializable dict."""
        return {
            "path": metadata.path,
            "backend_name": metadata.backend_name,
            "physical_path": metadata.physical_path,
            "size": metadata.size,
            "etag": metadata.etag,
            "mime_type": metadata.mime_type,
            "created_at": metadata.created_at.isoformat() if metadata.created_at else None,
            "modified_at": metadata.modified_at.isoformat() if metadata.modified_at else None,
            "version": metadata.version,
            "zone_id": metadata.zone_id,
            "created_by": metadata.created_by,
            "owner_id": metadata.owner_id,
            "entry_type": metadata.entry_type,
            "target_zone_id": metadata.target_zone_id,
            "i_links_count": metadata.i_links_count,
        }

    @staticmethod
    def from_json(obj: dict[str, Any]) -> FileMetadata:
        """Convert JSON dict to FileMetadata dataclass."""
        from nexus.core._metadata_generated import FileMetadata

        # Migration: convert legacy is_directory -> entry_type
        if "is_directory" in obj:
            is_dir = obj.pop("is_directory")
            if "entry_type" not in obj:
                obj["entry_type"] = 1 if is_dir else 0

        if obj.get("created_at"):
            obj["created_at"] = datetime.fromisoformat(obj["created_at"])
        if obj.get("modified_at"):
            obj["modified_at"] = datetime.fromisoformat(obj["modified_at"])
        return FileMetadata(**obj)

    # -- SQLAlchemy column values (MANUAL â€” different schema) ---------------

    @staticmethod
    def to_file_path_values(
        metadata: FileMetadata,
        *,
        include_version: bool = True,
    ) -> dict[str, Any]:
        """Convert FileMetadata to dict of FilePathModel column values.

        Keys are FilePathModel column names (not proto field names).
        """
        values: dict[str, Any] = {
            "virtual_path": metadata.path,
            "backend_id": metadata.backend_name or "local",
            "physical_path": metadata.physical_path or metadata.path,
            "size_bytes": metadata.size or 0,
            "content_hash": metadata.etag,
            "file_type": metadata.mime_type,
            "created_at": _to_naive(metadata.created_at) or _utcnow_naive(),
            "updated_at": _to_naive(metadata.modified_at) or _utcnow_naive(),
            "zone_id": metadata.zone_id or "default",
            "posix_uid": metadata.owner_id,
        }
        if include_version:
            values["current_version"] = 1
        return values

    @staticmethod
    def to_file_path_update_values(metadata: FileMetadata) -> dict[str, Any]:
        """Convert FileMetadata to dict for UPDATE operations."""
        return {
            "backend_id": metadata.backend_name,
            "physical_path": metadata.physical_path,
            "size_bytes": metadata.size or 0,
            "content_hash": metadata.etag,
            "file_type": metadata.mime_type,
            "updated_at": _to_naive(metadata.modified_at) or _utcnow_naive(),
        }
